# pve-cli Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a CLI for Proxmox VE to list, start, and stop VMs/LXCs.

**Architecture:** Standard Go CLI following existing patterns - Cobra for commands, YAML output, typed errors with exit codes. API client with auto node discovery.

**Tech Stack:** Go 1.21, Cobra, gopkg.in/yaml.v3

---

### Task 1: Project Scaffolding

**Files:**
- Create: `pve/go.mod`
- Create: `pve/pkg/pve/errors.go`
- Modify: `go.work` (add ./pve)

**Step 1: Create go.mod**

```bash
mkdir -p pve/pkg/pve pve/cmd/pve-cli
```

Create `pve/go.mod`:
```go
module github.com/schmoli/cli-tools/pve

go 1.21

require (
	github.com/spf13/cobra v1.10.2
	gopkg.in/yaml.v3 v3.0.1
)
```

**Step 2: Create errors.go**

Create `pve/pkg/pve/errors.go`:
```go
package pve

import "fmt"

type ErrorCode string

const (
	ErrConfig   ErrorCode = "CONFIG_ERROR"
	ErrAuth     ErrorCode = "AUTH_FAILED"
	ErrNotFound ErrorCode = "NOT_FOUND"
	ErrNetwork  ErrorCode = "NETWORK_ERROR"
	ErrAPI      ErrorCode = "API_ERROR"
)

type PveError struct {
	Code    ErrorCode
	Message string
}

func (e *PveError) Error() string {
	return e.Message
}

func (e *PveError) ExitCode() int {
	switch e.Code {
	case ErrConfig:
		return 1
	case ErrAuth:
		return 2
	case ErrNotFound:
		return 3
	case ErrNetwork:
		return 4
	case ErrAPI:
		return 5
	default:
		return 1
	}
}

func ConfigError(msg string) *PveError {
	return &PveError{Code: ErrConfig, Message: msg}
}

func AuthError(msg string) *PveError {
	return &PveError{Code: ErrAuth, Message: msg}
}

func NotFoundError(msg string) *PveError {
	return &PveError{Code: ErrNotFound, Message: msg}
}

func NetworkError(msg string) *PveError {
	return &PveError{Code: ErrNetwork, Message: msg}
}

func APIError(msg string) *PveError {
	return &PveError{Code: ErrAPI, Message: fmt.Sprintf("API error: %s", msg)}
}
```

**Step 3: Update go.work**

Add `./pve` to `go.work`:
```go
go 1.21

use (
	./common
	./nproxy
	./portainer
	./pve
	./trans
)
```

**Step 4: Run go mod tidy**

```bash
cd pve && go mod tidy && cd ..
```

**Step 5: Commit**

```bash
git add pve/ go.work
git commit -m "feat(pve): scaffold project structure"
```

---

### Task 2: Output Module

**Files:**
- Create: `pve/pkg/pve/output.go`
- Test: `pve/pkg/pve/output_test.go`

**Step 1: Write failing test**

Create `pve/pkg/pve/output_test.go`:
```go
package pve

import (
	"bytes"
	"testing"
)

func TestPrintYAML(t *testing.T) {
	var buf bytes.Buffer
	data := map[string]string{"name": "test"}

	err := PrintYAMLTo(&buf, data)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	expected := "name: test\n"
	if buf.String() != expected {
		t.Errorf("got %q, want %q", buf.String(), expected)
	}
}
```

**Step 2: Run test to verify it fails**

```bash
go test ./pve/pkg/pve/... -run TestPrintYAML -v
```
Expected: FAIL - PrintYAMLTo undefined

**Step 3: Write implementation**

Create `pve/pkg/pve/output.go`:
```go
package pve

import (
	"fmt"
	"io"
	"os"

	"gopkg.in/yaml.v3"
)

type ErrorOutput struct {
	Error ErrorDetail `yaml:"error"`
}

type ErrorDetail struct {
	Code    string `yaml:"code"`
	Message string `yaml:"message"`
}

func PrintYAMLTo(w io.Writer, data interface{}) error {
	enc := yaml.NewEncoder(w)
	enc.SetIndent(2)
	if err := enc.Encode(data); err != nil {
		return APIError(fmt.Sprintf("failed to serialize: %s", err))
	}
	return nil
}

func PrintYAML(data interface{}) error {
	return PrintYAMLTo(os.Stdout, data)
}

func PrintError(err error) {
	pe, ok := err.(*PveError)
	if !ok {
		fmt.Fprintf(os.Stderr, "error: %s\n", err)
		return
	}

	output := ErrorOutput{
		Error: ErrorDetail{
			Code:    string(pe.Code),
			Message: pe.Message,
		},
	}

	enc := yaml.NewEncoder(os.Stderr)
	enc.SetIndent(2)
	if err := enc.Encode(output); err != nil {
		fmt.Fprintf(os.Stderr, "error: %s\n", pe.Message)
	}
}
```

**Step 4: Run test to verify it passes**

```bash
go test ./pve/pkg/pve/... -run TestPrintYAML -v
```
Expected: PASS

**Step 5: Commit**

```bash
git add pve/pkg/pve/output.go pve/pkg/pve/output_test.go
git commit -m "feat(pve): add output module"
```

---

### Task 3: Models

**Files:**
- Create: `pve/pkg/pve/models.go`
- Test: `pve/pkg/pve/models_test.go`

**Step 1: Write failing test**

Create `pve/pkg/pve/models_test.go`:
```go
package pve

import "testing"

func TestFormatUptime(t *testing.T) {
	tests := []struct {
		seconds int64
		want    string
	}{
		{0, "0s"},
		{59, "59s"},
		{60, "1m"},
		{3600, "1h"},
		{3661, "1h 1m"},
		{86400, "1d"},
		{90061, "1d 1h 1m"},
	}

	for _, tt := range tests {
		got := FormatUptime(tt.seconds)
		if got != tt.want {
			t.Errorf("FormatUptime(%d) = %q, want %q", tt.seconds, got, tt.want)
		}
	}
}

func TestAPIVMStatusLabel(t *testing.T) {
	vm := &APIVM{Status: "running"}
	if vm.StatusLabel() != "running" {
		t.Errorf("got %q, want running", vm.StatusLabel())
	}

	vm.Status = "stopped"
	if vm.StatusLabel() != "stopped" {
		t.Errorf("got %q, want stopped", vm.StatusLabel())
	}
}
```

**Step 2: Run test to verify it fails**

```bash
go test ./pve/pkg/pve/... -run "TestFormatUptime|TestAPIVMStatusLabel" -v
```
Expected: FAIL - FormatUptime/APIVM undefined

**Step 3: Write implementation**

Create `pve/pkg/pve/models.go`:
```go
package pve

import "fmt"

// API response types

type APINode struct {
	Node   string `json:"node"`
	Status string `json:"status"`
}

type APINodesResponse struct {
	Data []APINode `json:"data"`
}

type APIVM struct {
	VMID      int64   `json:"vmid"`
	Name      string  `json:"name"`
	Status    string  `json:"status"`
	CPU       float64 `json:"cpu"`
	Cpus      int     `json:"cpus"`
	Mem       int64   `json:"mem"`
	MaxMem    int64   `json:"maxmem"`
	Uptime    int64   `json:"uptime"`
	NetIn     int64   `json:"netin"`
	NetOut    int64   `json:"netout"`
	DiskRead  int64   `json:"diskread"`
	DiskWrite int64   `json:"diskwrite"`
}

type APIVMListResponse struct {
	Data []APIVM `json:"data"`
}

type APINetworkInterface struct {
	Name        string `json:"name"`
	HardwareAddr string `json:"hardware-address"`
	IPAddresses []struct {
		IPAddress string `json:"ip-address"`
		IPType    string `json:"ip-address-type"`
	} `json:"ip-addresses"`
}

type APIQemuAgentNetworkResponse struct {
	Data struct {
		Result []APINetworkInterface `json:"result"`
	} `json:"data"`
}

type APILXCInterfaceResponse struct {
	Data []struct {
		Name   string `json:"name"`
		Inet   string `json:"inet"`
		Inet6  string `json:"inet6"`
		Hwaddr string `json:"hwaddr"`
	} `json:"data"`
}

type APITaskResponse struct {
	Data string `json:"data"`
}

// Output types

type Guest struct {
	VMID   int64  `yaml:"vmid"`
	Name   string `yaml:"name"`
	Type   string `yaml:"type"`
	Status string `yaml:"status"`
	CPU    int    `yaml:"cpu"`
	Memory int64  `yaml:"memory"`
	Uptime string `yaml:"uptime"`
	IP     string `yaml:"ip"`
}

type ActionResult struct {
	VMID   int64  `yaml:"vmid"`
	Name   string `yaml:"name"`
	Action string `yaml:"action"`
}

// Helper functions

func (vm *APIVM) StatusLabel() string {
	return vm.Status
}

func FormatUptime(seconds int64) string {
	if seconds == 0 {
		return "0s"
	}

	days := seconds / 86400
	seconds %= 86400
	hours := seconds / 3600
	seconds %= 3600
	minutes := seconds / 60

	var result string
	if days > 0 {
		result = fmt.Sprintf("%dd", days)
	}
	if hours > 0 {
		if result != "" {
			result += " "
		}
		result += fmt.Sprintf("%dh", hours)
	}
	if minutes > 0 && days == 0 {
		if result != "" {
			result += " "
		}
		result += fmt.Sprintf("%dm", minutes)
	}
	if result == "" {
		result = fmt.Sprintf("%ds", seconds)
	}
	return result
}

func (vm *APIVM) ToGuest(vmType, ip string) Guest {
	return Guest{
		VMID:   vm.VMID,
		Name:   vm.Name,
		Type:   vmType,
		Status: vm.StatusLabel(),
		CPU:    vm.Cpus,
		Memory: vm.MaxMem / 1024 / 1024, // Convert to MB
		Uptime: FormatUptime(vm.Uptime),
		IP:     ip,
	}
}
```

**Step 4: Run test to verify it passes**

```bash
go test ./pve/pkg/pve/... -run "TestFormatUptime|TestAPIVMStatusLabel" -v
```
Expected: PASS

**Step 5: Commit**

```bash
git add pve/pkg/pve/models.go pve/pkg/pve/models_test.go
git commit -m "feat(pve): add models"
```

---

### Task 4: API Client - Core

**Files:**
- Create: `pve/pkg/pve/client.go`
- Test: `pve/pkg/pve/client_test.go`

**Step 1: Write failing test**

Create `pve/pkg/pve/client_test.go`:
```go
package pve

import (
	"net/http"
	"net/http/httptest"
	"testing"
)

func TestClientGetNodes(t *testing.T) {
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if r.URL.Path != "/api2/json/nodes" {
			t.Errorf("unexpected path: %s", r.URL.Path)
		}
		if r.Header.Get("Authorization") == "" {
			t.Error("missing Authorization header")
		}
		w.WriteHeader(http.StatusOK)
		w.Write([]byte(`{"data":[{"node":"pve","status":"online"}]}`))
	}))
	defer server.Close()

	client := NewClient(server.URL, "user@pam!token", "secret", false)
	node, err := client.GetNode()
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if node != "pve" {
		t.Errorf("got node %q, want pve", node)
	}
}

func TestClientAuthHeader(t *testing.T) {
	var gotAuth string
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		gotAuth = r.Header.Get("Authorization")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte(`{"data":[{"node":"pve","status":"online"}]}`))
	}))
	defer server.Close()

	client := NewClient(server.URL, "user@pam!mytoken", "abc123", false)
	client.GetNode()

	expected := "PVEAPIToken=user@pam!mytoken=abc123"
	if gotAuth != expected {
		t.Errorf("got auth %q, want %q", gotAuth, expected)
	}
}
```

**Step 2: Run test to verify it fails**

```bash
go test ./pve/pkg/pve/... -run "TestClient" -v
```
Expected: FAIL - NewClient/GetNode undefined

**Step 3: Write implementation**

Create `pve/pkg/pve/client.go`:
```go
package pve

import (
	"crypto/tls"
	"encoding/json"
	"fmt"
	"net/http"
	"strings"
	"time"
)

type Client struct {
	baseURL    string
	tokenID    string
	tokenSecret string
	httpClient *http.Client
	node       string // cached node name
}

func NewClient(url, tokenID, tokenSecret string, insecure bool) *Client {
	client := &http.Client{
		Timeout: 10 * time.Second,
	}
	if insecure {
		client.Transport = &http.Transport{
			TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
		}
	}
	return &Client{
		baseURL:     strings.TrimSuffix(url, "/"),
		tokenID:     tokenID,
		tokenSecret: tokenSecret,
		httpClient:  client,
	}
}

func (c *Client) authHeader() string {
	return fmt.Sprintf("PVEAPIToken=%s=%s", c.tokenID, c.tokenSecret)
}

func (c *Client) get(path string, result interface{}) error {
	url := c.baseURL + path

	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return NetworkError(err.Error())
	}

	req.Header.Set("Authorization", c.authHeader())

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return NetworkError(err.Error())
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusOK:
		if err := json.NewDecoder(resp.Body).Decode(result); err != nil {
			return APIError(fmt.Sprintf("failed to parse response from %s: %s", path, err))
		}
		return nil
	case http.StatusUnauthorized, http.StatusForbidden:
		return AuthError(fmt.Sprintf("invalid or expired token for %s", path))
	case http.StatusNotFound:
		return NotFoundError(fmt.Sprintf("resource not found: %s", path))
	default:
		return APIError(fmt.Sprintf("unexpected status %d from %s", resp.StatusCode, path))
	}
}

func (c *Client) post(path string, result interface{}) error {
	url := c.baseURL + path

	req, err := http.NewRequest("POST", url, nil)
	if err != nil {
		return NetworkError(err.Error())
	}

	req.Header.Set("Authorization", c.authHeader())

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return NetworkError(err.Error())
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusOK:
		if result != nil {
			if err := json.NewDecoder(resp.Body).Decode(result); err != nil {
				return APIError(fmt.Sprintf("failed to parse response from %s: %s", path, err))
			}
		}
		return nil
	case http.StatusUnauthorized, http.StatusForbidden:
		return AuthError(fmt.Sprintf("invalid or expired token for %s", path))
	case http.StatusNotFound:
		return NotFoundError(fmt.Sprintf("resource not found: %s", path))
	default:
		return APIError(fmt.Sprintf("unexpected status %d from %s", resp.StatusCode, path))
	}
}

func (c *Client) GetNode() (string, error) {
	if c.node != "" {
		return c.node, nil
	}

	var resp APINodesResponse
	if err := c.get("/api2/json/nodes", &resp); err != nil {
		return "", err
	}

	if len(resp.Data) == 0 {
		return "", APIError("no nodes found")
	}

	c.node = resp.Data[0].Node
	return c.node, nil
}
```

**Step 4: Run test to verify it passes**

```bash
go test ./pve/pkg/pve/... -run "TestClient" -v
```
Expected: PASS

**Step 5: Commit**

```bash
git add pve/pkg/pve/client.go pve/pkg/pve/client_test.go
git commit -m "feat(pve): add API client core"
```

---

### Task 5: API Client - List VMs/LXCs

**Files:**
- Modify: `pve/pkg/pve/client.go`
- Modify: `pve/pkg/pve/client_test.go`

**Step 1: Write failing test**

Add to `pve/pkg/pve/client_test.go`:
```go
func TestClientListGuests(t *testing.T) {
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case "/api2/json/nodes":
			w.Write([]byte(`{"data":[{"node":"pve","status":"online"}]}`))
		case "/api2/json/nodes/pve/qemu":
			w.Write([]byte(`{"data":[{"vmid":100,"name":"vm1","status":"running","cpus":4,"maxmem":8589934592,"uptime":3600}]}`))
		case "/api2/json/nodes/pve/lxc":
			w.Write([]byte(`{"data":[{"vmid":101,"name":"ct1","status":"running","cpus":2,"maxmem":536870912,"uptime":7200}]}`))
		case "/api2/json/nodes/pve/qemu/100/agent/network-get-interfaces":
			w.Write([]byte(`{"data":{"result":[{"name":"eth0","ip-addresses":[{"ip-address":"192.168.1.100","ip-address-type":"ipv4"}]}]}}`))
		case "/api2/json/nodes/pve/lxc/101/interfaces":
			w.Write([]byte(`{"data":[{"name":"eth0","inet":"192.168.1.101/24"}]}`))
		default:
			w.WriteHeader(http.StatusNotFound)
		}
	}))
	defer server.Close()

	client := NewClient(server.URL, "user@pam!token", "secret", false)
	guests, err := client.ListGuests()
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	if len(guests) != 2 {
		t.Fatalf("got %d guests, want 2", len(guests))
	}

	if guests[0].VMID != 100 || guests[0].Type != "qemu" {
		t.Errorf("guest 0: got vmid=%d type=%s, want vmid=100 type=qemu", guests[0].VMID, guests[0].Type)
	}
	if guests[1].VMID != 101 || guests[1].Type != "lxc" {
		t.Errorf("guest 1: got vmid=%d type=%s, want vmid=101 type=lxc", guests[1].VMID, guests[1].Type)
	}
}
```

**Step 2: Run test to verify it fails**

```bash
go test ./pve/pkg/pve/... -run "TestClientListGuests" -v
```
Expected: FAIL - ListGuests undefined

**Step 3: Write implementation**

Add to `pve/pkg/pve/client.go`:
```go
func (c *Client) ListGuests() ([]Guest, error) {
	node, err := c.GetNode()
	if err != nil {
		return nil, err
	}

	var guests []Guest

	// Get VMs
	var vmResp APIVMListResponse
	if err := c.get(fmt.Sprintf("/api2/json/nodes/%s/qemu", node), &vmResp); err != nil {
		return nil, err
	}
	for _, vm := range vmResp.Data {
		ip := c.getVMIP(node, vm.VMID)
		guests = append(guests, vm.ToGuest("qemu", ip))
	}

	// Get LXCs
	var lxcResp APIVMListResponse
	if err := c.get(fmt.Sprintf("/api2/json/nodes/%s/lxc", node), &lxcResp); err != nil {
		return nil, err
	}
	for _, lxc := range lxcResp.Data {
		ip := c.getLXCIP(node, lxc.VMID)
		guests = append(guests, lxc.ToGuest("lxc", ip))
	}

	return guests, nil
}

func (c *Client) getVMIP(node string, vmid int64) string {
	var resp APIQemuAgentNetworkResponse
	path := fmt.Sprintf("/api2/json/nodes/%s/qemu/%d/agent/network-get-interfaces", node, vmid)
	if err := c.get(path, &resp); err != nil {
		return "N/A"
	}

	for _, iface := range resp.Data.Result {
		if iface.Name == "lo" {
			continue
		}
		for _, addr := range iface.IPAddresses {
			if addr.IPType == "ipv4" && !strings.HasPrefix(addr.IPAddress, "127.") {
				return addr.IPAddress
			}
		}
	}
	return "N/A"
}

func (c *Client) getLXCIP(node string, vmid int64) string {
	var resp APILXCInterfaceResponse
	path := fmt.Sprintf("/api2/json/nodes/%s/lxc/%d/interfaces", node, vmid)
	if err := c.get(path, &resp); err != nil {
		return "N/A"
	}

	for _, iface := range resp.Data {
		if iface.Name == "lo" {
			continue
		}
		if iface.Inet != "" {
			// Strip CIDR notation
			ip := strings.Split(iface.Inet, "/")[0]
			if !strings.HasPrefix(ip, "127.") {
				return ip
			}
		}
	}
	return "N/A"
}
```

**Step 4: Run test to verify it passes**

```bash
go test ./pve/pkg/pve/... -run "TestClientListGuests" -v
```
Expected: PASS

**Step 5: Commit**

```bash
git add pve/pkg/pve/client.go pve/pkg/pve/client_test.go
git commit -m "feat(pve): add list guests API"
```

---

### Task 6: API Client - Start/Stop

**Files:**
- Modify: `pve/pkg/pve/client.go`
- Modify: `pve/pkg/pve/client_test.go`

**Step 1: Write failing test**

Add to `pve/pkg/pve/client_test.go`:
```go
func TestClientStartGuest(t *testing.T) {
	var startedPath string
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case "/api2/json/nodes":
			w.Write([]byte(`{"data":[{"node":"pve","status":"online"}]}`))
		case "/api2/json/nodes/pve/qemu/100/status/start":
			startedPath = r.URL.Path
			w.Write([]byte(`{"data":"UPID:pve:00001234:00000000:12345678:qmstart:100:user@pam:"}`))
		default:
			w.WriteHeader(http.StatusNotFound)
		}
	}))
	defer server.Close()

	client := NewClient(server.URL, "user@pam!token", "secret", false)
	err := client.StartGuest(100, "qemu")
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if startedPath == "" {
		t.Error("start endpoint was not called")
	}
}

func TestClientStopGuest(t *testing.T) {
	var stoppedPath string
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case "/api2/json/nodes":
			w.Write([]byte(`{"data":[{"node":"pve","status":"online"}]}`))
		case "/api2/json/nodes/pve/lxc/101/status/shutdown":
			stoppedPath = r.URL.Path
			w.Write([]byte(`{"data":"UPID:pve:00001234:00000000:12345678:vzshutdown:101:user@pam:"}`))
		default:
			w.WriteHeader(http.StatusNotFound)
		}
	}))
	defer server.Close()

	client := NewClient(server.URL, "user@pam!token", "secret", false)
	err := client.StopGuest(101, "lxc")
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if stoppedPath == "" {
		t.Error("stop endpoint was not called")
	}
}
```

**Step 2: Run test to verify it fails**

```bash
go test ./pve/pkg/pve/... -run "TestClientStartGuest|TestClientStopGuest" -v
```
Expected: FAIL - StartGuest/StopGuest undefined

**Step 3: Write implementation**

Add to `pve/pkg/pve/client.go`:
```go
func (c *Client) StartGuest(vmid int64, vmType string) error {
	node, err := c.GetNode()
	if err != nil {
		return err
	}

	path := fmt.Sprintf("/api2/json/nodes/%s/%s/%d/status/start", node, vmType, vmid)
	var resp APITaskResponse
	return c.post(path, &resp)
}

func (c *Client) StopGuest(vmid int64, vmType string) error {
	node, err := c.GetNode()
	if err != nil {
		return err
	}

	path := fmt.Sprintf("/api2/json/nodes/%s/%s/%d/status/shutdown", node, vmType, vmid)
	var resp APITaskResponse
	return c.post(path, &resp)
}

func (c *Client) FindGuestType(vmid int64) (string, string, error) {
	node, err := c.GetNode()
	if err != nil {
		return "", "", err
	}

	// Try QEMU first
	var vmResp APIVMListResponse
	if err := c.get(fmt.Sprintf("/api2/json/nodes/%s/qemu", node), &vmResp); err == nil {
		for _, vm := range vmResp.Data {
			if vm.VMID == vmid {
				return "qemu", vm.Name, nil
			}
		}
	}

	// Try LXC
	var lxcResp APIVMListResponse
	if err := c.get(fmt.Sprintf("/api2/json/nodes/%s/lxc", node), &lxcResp); err == nil {
		for _, lxc := range lxcResp.Data {
			if lxc.VMID == vmid {
				return "lxc", lxc.Name, nil
			}
		}
	}

	return "", "", NotFoundError(fmt.Sprintf("guest %d not found", vmid))
}
```

**Step 4: Run test to verify it passes**

```bash
go test ./pve/pkg/pve/... -run "TestClientStartGuest|TestClientStopGuest" -v
```
Expected: PASS

**Step 5: Commit**

```bash
git add pve/pkg/pve/client.go pve/pkg/pve/client_test.go
git commit -m "feat(pve): add start/stop guest API"
```

---

### Task 7: CLI Main Entry

**Files:**
- Create: `pve/cmd/pve-cli/main.go`

**Step 1: Create main.go**

Create `pve/cmd/pve-cli/main.go`:
```go
package main

import (
	"fmt"
	"os"
	"strings"

	"github.com/spf13/cobra"
	"github.com/schmoli/cli-tools/pve/pkg/pve"
)

var version = "dev"

var (
	flagURL         string
	flagTokenID     string
	flagTokenSecret string
	flagInsecure    bool
)

var rootCmd = &cobra.Command{
	Use:     "pve-cli",
	Short:   "CLI for Proxmox VE API",
	Version: version,
}

func init() {
	rootCmd.PersistentFlags().StringVar(&flagURL, "url", "", "Proxmox URL (or set PVE_URL)")
	rootCmd.PersistentFlags().StringVar(&flagTokenID, "token-id", "", "Token ID (or set PVE_TOKEN_ID)")
	rootCmd.PersistentFlags().StringVar(&flagTokenSecret, "token", "", "Token secret (or set PVE_TOKEN_SECRET)")
	rootCmd.PersistentFlags().BoolVarP(&flagInsecure, "insecure", "k", false, "Skip TLS certificate verification")

	rootCmd.AddCommand(listCmd)
	rootCmd.AddCommand(startCmd)
	rootCmd.AddCommand(stopCmd)
}

func getConfig() (string, string, string, error) {
	url := flagURL
	if url == "" {
		url = os.Getenv("PVE_URL")
	}
	if url == "" {
		return "", "", "", pve.ConfigError("missing URL. Use --url or set PVE_URL")
	}

	tokenID := flagTokenID
	if tokenID == "" {
		tokenID = os.Getenv("PVE_TOKEN_ID")
	}
	if tokenID == "" {
		return "", "", "", pve.ConfigError("missing token ID. Use --token-id or set PVE_TOKEN_ID")
	}

	tokenSecret := flagTokenSecret
	if tokenSecret == "" {
		tokenSecret = os.Getenv("PVE_TOKEN_SECRET")
	}
	if tokenSecret == "" {
		return "", "", "", pve.ConfigError("missing token secret. Use --token or set PVE_TOKEN_SECRET")
	}

	if !strings.HasPrefix(url, "http://") && !strings.HasPrefix(url, "https://") {
		return "", "", "", pve.ConfigError("URL must start with http:// or https://")
	}

	return url, tokenID, tokenSecret, nil
}

func getClient() (*pve.Client, error) {
	url, tokenID, tokenSecret, err := getConfig()
	if err != nil {
		return nil, err
	}
	return pve.NewClient(url, tokenID, tokenSecret, flagInsecure), nil
}

func parseVMID(arg string) (int64, error) {
	var id int64
	if _, err := fmt.Sscanf(arg, "%d", &id); err != nil {
		return 0, pve.ConfigError(fmt.Sprintf("invalid VMID: %s", arg))
	}
	if id <= 0 {
		return 0, pve.ConfigError("VMID must be positive")
	}
	return id, nil
}

func handleError(err error) {
	pve.PrintError(err)
	if pe, ok := err.(*pve.PveError); ok {
		os.Exit(pe.ExitCode())
	}
	os.Exit(1)
}

func main() {
	if err := rootCmd.Execute(); err != nil {
		os.Exit(1)
	}
}

var listCmd = &cobra.Command{
	Use:   "list",
	Short: "List all VMs and LXCs",
	RunE: func(cmd *cobra.Command, args []string) error {
		client, err := getClient()
		if err != nil {
			handleError(err)
			return nil
		}

		guests, err := client.ListGuests()
		if err != nil {
			handleError(err)
			return nil
		}

		if err := pve.PrintYAML(guests); err != nil {
			handleError(err)
		}
		return nil
	},
}

var startCmd = &cobra.Command{
	Use:   "start <vmid>",
	Short: "Start a VM or LXC",
	Args:  cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		vmid, err := parseVMID(args[0])
		if err != nil {
			handleError(err)
			return nil
		}

		client, err := getClient()
		if err != nil {
			handleError(err)
			return nil
		}

		vmType, name, err := client.FindGuestType(vmid)
		if err != nil {
			handleError(err)
			return nil
		}

		if err := client.StartGuest(vmid, vmType); err != nil {
			handleError(err)
			return nil
		}

		result := pve.ActionResult{
			VMID:   vmid,
			Name:   name,
			Action: "started",
		}
		if err := pve.PrintYAML(result); err != nil {
			handleError(err)
		}
		return nil
	},
}

var stopCmd = &cobra.Command{
	Use:   "stop <vmid>",
	Short: "Stop a VM or LXC",
	Args:  cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		vmid, err := parseVMID(args[0])
		if err != nil {
			handleError(err)
			return nil
		}

		client, err := getClient()
		if err != nil {
			handleError(err)
			return nil
		}

		vmType, name, err := client.FindGuestType(vmid)
		if err != nil {
			handleError(err)
			return nil
		}

		if err := client.StopGuest(vmid, vmType); err != nil {
			handleError(err)
			return nil
		}

		result := pve.ActionResult{
			VMID:   vmid,
			Name:   name,
			Action: "stopped",
		}
		if err := pve.PrintYAML(result); err != nil {
			handleError(err)
		}
		return nil
	},
}
```

**Step 2: Verify build**

```bash
go build -o /dev/null ./pve/cmd/pve-cli
```
Expected: Build succeeds

**Step 3: Commit**

```bash
git add pve/cmd/pve-cli/main.go
git commit -m "feat(pve): add CLI commands"
```

---

### Task 8: Build Infrastructure

**Files:**
- Modify: `build.sh`
- Modify: `.github/workflows/ci.yml`
- Modify: `.github/workflows/release-please.yml`
- Modify: `install.sh`
- Modify: `README.md`

**Step 1: Update build.sh**

Add after trans-cli block in `build.sh`:
```bash
if [ -f "pve/cmd/pve-cli/main.go" ]; then
    build_tool "pve-cli" "pve"
fi
```

**Step 2: Update ci.yml**

Add test step after trans-cli:
```yaml
      - name: Test pve-cli
        run: go test -v ./pve/...
```

Add pve-cli to build step:
```yaml
          go build -ldflags "${LDFLAGS}" -o pve-cli ./pve/cmd/pve-cli
          tar -czvf cli-tools-${{ matrix.goos }}-${{ matrix.goarch }}.tar.gz portainer-cli nproxy-cli trans-cli pve-cli
```

**Step 3: Update release-please.yml**

Add pve-cli to build step:
```yaml
          go build -ldflags "${LDFLAGS}" -o pve-cli ./pve/cmd/pve-cli
          tar -czvf cli-tools-${{ matrix.goos }}-${{ matrix.goarch }}.tar.gz portainer-cli nproxy-cli trans-cli pve-cli
```

**Step 4: Update install.sh**

Add pve-cli to install section:
```bash
mv "${TMPDIR}/pve-cli" "${INSTALL_DIR}/"
chmod +x "${INSTALL_DIR}/portainer-cli" "${INSTALL_DIR}/nproxy-cli" "${INSTALL_DIR}/trans-cli" "${INSTALL_DIR}/pve-cli"
```

Add to installed list:
```bash
echo "  - pve-cli"
```

Add completions:
```bash
        echo "    source <(pve-cli completion bash)"
        echo "    source <(pve-cli completion zsh)"
```

**Step 5: Update README.md**

Add PVE config vars to table, add pve-cli section with usage examples.

**Step 6: Verify build**

```bash
./build.sh
```
Expected: All tests pass, all binaries built

**Step 7: Commit**

```bash
git add build.sh .github/workflows/ci.yml .github/workflows/release-please.yml install.sh README.md
git commit -m "feat(pve): add build infrastructure and docs"
```

---

### Task 9: Final Verification

**Step 1: Run all tests**

```bash
go test ./pve/... -v
```
Expected: All tests pass

**Step 2: Build locally**

```bash
./build.sh
```
Expected: pve-cli binary in bin/

**Step 3: Manual smoke test (if PVE available)**

```bash
export PVE_URL=https://your-pve:8006
export PVE_TOKEN_ID=user@pam!tokenname
export PVE_TOKEN_SECRET=your-secret
./bin/pve-cli list
```

---

Plan complete and saved to `docs/plans/2025-12-07-pve-cli.md`.

**Two execution options:**

1. **Subagent-Driven (this session)** - I dispatch fresh subagent per task, review between tasks, fast iteration

2. **Parallel Session (separate)** - Open new session with executing-plans, batch execution with checkpoints

Which approach?
